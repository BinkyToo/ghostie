<!doctype html>
<html>
    <head>
	<meta charset="UTF-8" />
	<title>Tilemap!</title>
	<script src="phaser.js"></script>
    </head>
    <body>

    <script type="text/javascript">

    window.onload = function() {
	var game = new Phaser.Game(800, 480, Phaser.AUTO, 'phaser-example', { preload: preload, create: create, update: update, render: render });

	function preload() {
	    game.load.image('rain', 'rain.png');
	    game.load.image('wind', 'wind.png');
	    game.load.image('nearhorizon', 'horizon2.png');
	    game.load.image('farhorizon', 'horizon1.png');
	    game.load.tilemap('map', 'test.json', null, Phaser.Tilemap.TILED_JSON);
	    game.load.image('basic', 'main.png');
	    game.load.image('special', 'special.png');
	    game.load.image('tree', 'tree.png');
	    game.load.image('cavewall', 'cavewall.png');
	    game.load.spritesheet('ghost', 'ghost-wavey.png', 40, 80, 8);

	}

	var facing = 'left';
	var jumpTimer = 0;
	var cursors;
	var jumpButton;

	var map;
	var layer;
	var background;
	var nearhorizon;
	var rain;

	function create() {

	    game.physics.startSystem(Phaser.Physics.P2JS);

	    game.stage.backgroundColor = '#808070';
	    rain = game.add.tileSprite(0, 0, 2000, 2000, 'rain', 0);
	    wind = game.add.tileSprite(0, 0, 2000, 2000, 'wind', 0);
	    //var nearhorizon = game.add.image(0, 200, 'nearhorizon');
	    //farhorizon = game.add.tileSprite(0, 400, 1600, 600, 'farhorizon', 0);
	    //nearhorizon = game.add.tileSprite(0, 200, 1600, 600, 'nearhorizon', 0);

	    map = game.add.tilemap('map');
	    
	    map.addTilesetImage('cavewall');
	    background = map.createLayer('Background');
	    
	    ghost = game.add.sprite(120, 450, 'ghost');
	    game.physics.enable(ghost, Phaser.Physics.P2JS);
	    var wave = ghost.animations.add('wave');
	    ghost.animations.play('wave', 25, true);
	    ghost.body.fixedRotation = true;
	    ghost.body.restitution = 0.5;
	    ghost.body.damping = 0.6;
	    ghost.body.clearShapes();
	    ghost.body.addCapsule(36, 12, 0, 0, 1.57)
;
	    map.addTilesetImage('basic');
	    map.addTilesetImage('special');
	    map.addTilesetImage('tree');

	    layer = map.createLayer('Midground');
	    //collisionLayer = map.createLayer('Object Layer 1');
	    //rain = game.add.tileSprite(0, 0, 2000, 2000, 'rain', 0);

	    layer.resizeWorld();

	    //  Set the tiles for collision.
	    //  Do this BEFORE generating the p2 bodies below.
	    //map.setCollisionBetween(2, 39);

	    //  Convert the tilemap layer into bodies. Only tiles that collide (see above) are created.
	    //  This call returns an array of body objects which you can perform addition actions on if
	    //  required. There is also a parameter to control optimising the map build.
	    //game.physics.p2.convertTilemap(map, layer);
	    //ghost.body.collides(boundsCG);
	    //var boundsCG =  game.physics.p2.createCollisionGroup();
	    game.physics.p2.convertCollisionObjects(map,"Collision Layer", true); 
	    //ghost.collides(collisionLayer);
	    //var bounds = game.physics.p2.convertCollisionObjects(map, 'Object Layer 1', true);   
	    //for(var bound in bounds)
	    //{
	    //  bounds[bound].setCollisionGroup(boundsCG);
	    //  bounds[bound].collides(ghost);
	    //}
      
	    game.physics.p2.restitution = 0.5;
	    game.physics.p2.gravity.y = 300;


	    game.camera.follow(ghost);

	    cursors = game.input.keyboard.createCursorKeys();
	    jumpButton = game.input.keyboard.addKey(Phaser.Keyboard.SPACEBAR);

	}

	function update() {
	    ghost.angle = ghost.body.velocity.x / 15
	    if (ghost.body.velocity.x < 0){
		ghost.scale.setTo(1+Math.abs(ghost.body.velocity.x/2000), 1+Math.abs(ghost.body.velocity.y/1000))
	    }
	    else {
		ghost.scale.setTo(-1-Math.abs(ghost.body.velocity.x/2000), 1+Math.abs(ghost.body.velocity.y/1000))
	    }
	    //nearhorizon.tilePosition.x = -game.camera.position.x/8;
	    //farhorizon.tilePosition.x = -game.camera.position.x/16;
	    //nearhorizon.tilePosition.y = -game.camera.position.y/8;
	    //farhorizon.tilePosition.y = -game.camera.position.y/16;
	    //background.tilePosition.x = -game.camera.position.x/16;
	    //background.tilePosition.y = -game.camera.position.y/8;
	    rain.tilePosition.x -= 1;
	    rain.tilePosition.y += 2;
	    wind.tilePosition.x -= 2;
	    wind.tilePosition.y += 1;

	    if (cursors.left.isDown)
	    {
		//ghost.scale.x = 1;
		if (ghost.body.velocity.x >= -250) {
		  ghost.body.velocity.x -= 10;
		}
		ghost.body.moveDown(40);

	    }
	    else if (cursors.right.isDown)
	    {
		//ghost.scale.x = -1;
		if (ghost.body.velocity.x <= 250) {
		  ghost.body.velocity.x += 10;
		}
		ghost.body.moveDown(40);

	    }

	    else if (cursors.up.isDown)
	    {
		if (ghost.body.velocity.y >= -75) {
		  ghost.body.velocity.y -= 10;
		  }
	    }

	}



	function render() {

	}
    };

    </script>

    </body>
</html>